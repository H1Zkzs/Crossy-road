<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Crossy Road — Fixed Gray Screen</title>
<style>
html,body{height:100%;margin:0;font-family:Inter,Segoe UI,system-ui,Arial;overflow:hidden;background:#222;}
canvas{display:block;}
#hud{position:absolute;top:10px;left:10px;color:#fff;font-weight:700;font-size:18px;z-index:10;}
#controls{position:absolute;top:10px;right:10px;z-index:10;}
#controls select,#controls button{padding:6px 10px;margin-left:5px;border-radius:6px;border:none;background:#444;color:#fff;cursor:pointer;}
#shopModal,#skinModal{display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#333;color:#fff;padding:20px;border-radius:10px;z-index:20;}
#shopModal button,#skinModal button{padding:6px 10px;margin-top:10px;border-radius:6px;border:none;background:#444;color:#fff;cursor:pointer;}
#skinOptions button{margin:5px;}
#googleSignInButton{position:absolute;top:50px;right:10px;z-index:15;}
</style>
<script src="https://accounts.google.com/gsi/client" async defer></script>
</head>
<body>
<div id="hud">Score: 0 | Coins: 0</div>
<div id="controls">
  <select id="difficulty">
    <option value="easy">Easy</option>
    <option value="medium" selected>Medium</option>
    <option value="hard">Hard</option>
  </select>
  <button id="restart">Restart</button>
  <button id="shopButton">Shop</button>
  <button id="switchSkin">Switch Skin</button>
</div>

<div id="shopModal">
  <div>Mystery Box (10 coins)</div>
  <button id="buyBox">Open Box</button>
  <div id="newSkin"></div>
  <button id="closeShop">Close</button>
</div>

<div id="skinModal">
  <div>Pick a skin:</div>
  <div id="skinOptions"></div>
  <button id="closeSkinMenu">Close</button>
</div>

<div id="googleSignInButton"></div>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('hud');
const difficultyEl = document.getElementById('difficulty');

let CELL = 60;
let WIDTH = window.innerWidth;
let HEIGHT = window.innerHeight;
const MAX_COLUMNS = 30;
const MIN_COLUMNS = 6;
const MAX_ROWS = 20;
const MIN_ROWS = 6;
let COLUMNS = Math.max(MIN_COLUMNS, Math.min(Math.floor(WIDTH/CELL), MAX_COLUMNS));
let ROWS_VISIBLE = Math.max(MIN_ROWS, Math.min(Math.floor(HEIGHT/CELL), MAX_ROWS));
canvas.width = WIDTH;
canvas.height = HEIGHT;

function rnd(a,b){return Math.random()*(b-a)+a;}
function randint(a,b){return Math.floor(rnd(a,b+1));}

// -------------------- Load/Save --------------------
function loadProgress(){
  const data = localStorage.getItem("miniCrossySave");
  if(data){
    try { return JSON.parse(data); } catch(e) {}
  }
  return null;
}
function saveProgress(){
  const obj = {
    coins: game.coins,
    skinColor: game.player.color,
    ownedSkins: ownedSkins
  };
  localStorage.setItem("miniCrossySave", JSON.stringify(obj));
}

// -------------------- Classes --------------------
class Player{
  constructor(){ this.reset(); this.color="#2b8a3e"; }
  reset(){
    this.col = Math.floor(COLUMNS/2);
    this.row = ROWS_VISIBLE-1;
    this.x = this.col*CELL + CELL/2;
    this.y = this.row*CELL + CELL/2;
    this.size = 40;
    this.alive = true;
  }
  draw(){
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x-20,this.y-20,40,40);
    ctx.fillStyle="#fff";
    ctx.fillRect(this.x-10,this.y-10,6,6);
    ctx.fillRect(this.x+4,this.y-10,6,6);
    ctx.fillStyle="#000";
    ctx.fillRect(this.x-8,this.y-8,2,2);
    ctx.fillRect(this.x+6,this.y-8,2,2);
  }
  move(d){
    if(!this.alive) return;
    let newCol=this.col,newRow=this.row;
    if(d==="up" && this.row>0) newRow--;
    if(d==="down" && this.row<ROWS_VISIBLE-1) newRow++;
    if(d==="left" && this.col>0) newCol--;
    if(d==="right" && this.col<COLUMNS-1) newCol++;
    for(let tree of game.trees){
      if(tree.row===newRow && tree.col===newCol) return;
    }
    this.col = newCol;
    this.row = newRow;
    this.x = this.col*CELL + CELL/2;
    this.y = this.row*CELL + CELL/2;
    if(d==="up") game.onUp();
  }
}

class Car{
  constructor(x,y,w,h,s,dir,c,lane){this.x=x;this.y=y;this.w=w;this.h=h;this.speed=s;this.dir=dir;this.color=c;this.lane=lane;}
  update(dt){ this.x += this.speed * dt * (this.dir==="right"?1:-1);}
  draw(){
    ctx.fillStyle=this.color;
    ctx.fillRect(this.x,this.y-this.h/2+8,this.w,this.h-16);
    ctx.fillStyle="#ddd";
    ctx.fillRect(this.x+this.w*0.25,this.y-this.h/2,this.w*0.5,(this.h/2)-4);
    ctx.fillStyle="#111";
    ctx.beginPath(); ctx.arc(this.x + this.w*0.2,this.y + this.h/2-4,8,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(this.x + this.w*0.8,this.y + this.h/2-4,8,0,Math.PI*2); ctx.fill();
  }
  rect(){return {x:this.x,y:this.y-this.h/2,w:this.w,h:this.h};}
}

class Train{
  constructor(x,y,speed,dir){this.x=x; this.y=y; this.w=500; this.h=50; this.speed=speed; this.dir=dir;}
  update(dt){ this.x += this.speed * dt * (this.dir==="right"?1:-1);}
  draw(){
    ctx.fillStyle="#ff0000";
    ctx.fillRect(this.x,this.y-this.h/2,this.w,this.h);
    ctx.fillStyle="#add8e6";
    for(let i=0;i<this.w-60;i+=60) ctx.fillRect(this.x+20+i,this.y-this.h/2+8,40,this.h-16);
    ctx.fillStyle="#aa0000";
    if(this.dir==="right") ctx.fillRect(this.x+this.w-60,this.y-this.h/2-5,60,this.h+10);
    else ctx.fillRect(this.x,this.y-this.h/2-5,60,this.h+10);
  }
  rect(){return {x:this.x,y:this.y-this.h/2,w:this.w,h:this.h};}
}

class Tree{
  constructor(col,row){this.col=col; this.row=row; this.x = col*CELL + CELL/2; this.y = row*CELL + CELL/2; this.trunkWidth = 12; this.trunkHeight = 12; this.leavesSize = 30;}
  draw(){
    ctx.fillStyle="#8b5a2b";
    ctx.fillRect(this.x-this.trunkWidth/2,this.y+CELL/2-this.trunkHeight,this.trunkWidth,this.trunkHeight);
    ctx.fillStyle="#228b22";
    ctx.fillRect(this.x-this.leavesSize/2,this.y+CELL/2-this.trunkHeight-this.leavesSize,this.leavesSize,this.leavesSize);
  }
}

class Coin{
  constructor(col,row){
    this.col = col;
    this.row = row;
    this.x = col*CELL+CELL/2;
    this.y = row*CELL+CELL/2;
    this.radius = 10;
  }
  draw(){
    ctx.fillStyle="gold";
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
    ctx.fill();
  }
  rect(){return {x:this.x-this.radius,y:this.y-this.radius,w:this.radius*2,h:this.radius*2};}
}

// -------------------- Game --------------------
let ownedSkins = ["#2b8a3e"];
class Game{
  constructor(){
    this.player = new Player(); // init player first
    const saved = loadProgress();
    this.coins = saved?.coins || 0;
    if(saved?.skinColor) this.player.color = saved.skinColor;
    if(saved?.ownedSkins) ownedSkins = saved.ownedSkins;
    this.init();
  }
  init(){
    this.lanes=[]; this.cars=[]; this.trains=[]; this.trees=[]; this.coinsArr=[];
    this.trainTimer=0; this.score=0; this.gameOver=false; this.pendingReset=false;
    this.setDifficulty(difficultyEl.value);
    this.generateMap(true);
    this.updateHUD();
  }
  setDifficulty(level){
    if(level==="easy"){ this.baseSpeed=80; this.spawnGap=1.5;}
    else if(level==="medium"){ this.baseSpeed=130; this.spawnGap=1.0;}
    else if(level==="hard"){ this.baseSpeed=200; this.spawnGap=0.6;}
  }

  generateMap(initial=false){
    this.lanes=[]; this.cars=[]; this.trains=[]; this.trees=[]; this.coinsArr=[]; this.trainTimer=0;
    WIDTH = window.innerWidth; HEIGHT = window.innerHeight;
    COLUMNS=Math.max(MIN_COLUMNS, Math.min(Math.floor(WIDTH/CELL), MAX_COLUMNS));
    ROWS_VISIBLE=Math.max(MIN_ROWS, Math.min(Math.floor(HEIGHT/CELL), MAX_ROWS));
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    let trainRow = (ROWS_VISIBLE>3)?randint(1,ROWS_VISIBLE-2):-1;

    for(let r=0;r<ROWS_VISIBLE-1;r++){
      let type="road";
      if(r===0) type="safe";
      else if(r===trainRow) type="train";
      else if(Math.random()<0.15) type="safe";

      let speedFactor = 1+this.score*0.03;
      let speed = rnd(this.baseSpeed,this.baseSpeed*1.2)*speedFactor;
      let dir = Math.random()<0.5?"left":"right";
      this.lanes.push({row:r,type,speed,dir,car:null});

      if(initial && type==="road"){
        this.spawnCarInLane(this.lanes[r]);
      }

      // Trees
      if(type==="safe" && r!==0){
        let maxTrees=Math.min(6,Math.max(1,Math.floor(COLUMNS*0.2))), tries=0;
        while(this.trees.filter(t=>t.row===r).length<maxTrees && tries<30){
          tries++; let c=randint(0,COLUMNS-1);
          if(!this.trees.some(t=>t.row===r && t.col===c)) this.trees.push(new Tree(c,r));
        }
      }
    }

    this.lanes.push({row:ROWS_VISIBLE-1,type:"safe",speed:0,dir:"right",car:null});

    // Coins
    const roadRows = this.lanes.filter(l=>l.type==="road").map(l=>l.row);
    for(let i=0;i<6;i++){
      let r = roadRows[randint(0,roadRows.length-1)];
      let c = randint(0,COLUMNS-1);
      this.coinsArr.push(new Coin(c,r));
    }
  }

  spawnCarInLane(lane){
    let y = lane.row*CELL + CELL/2;
    let h = 40;
    let w = randint(80,140);

    // Random direction
    let dir = Math.random()<0.5?"left":"right";
    lane.dir = dir;

    // Random off-screen start
    let safeDistance = 100;
    let x = dir==="right" ? -w - randint(0,200) : WIDTH + randint(0,200);

    let speed = lane.speed * rnd(0.7,1.3);
    let color = ["#f44","#4f4","#48f","#fa0","#a0f"][randint(0,4)];
    let car = new Car(x,y,w,h,speed,dir,color,lane);
    lane.car = car;
    this.cars.push(car);
  }

  update(dt){
    if(this.gameOver) return;
    for(let lane of this.lanes){ if(lane.type==="road" && !lane.car) this.spawnCarInLane(lane);}
    for(let i=0;i<this.cars.length;i++) this.cars[i].update(dt);
    this.cars = this.cars.filter(c=>{const visible=c.x+c.w>-200 && c.x<WIDTH+200; if(!visible && c.lane) c.lane.car=null; return visible;});

    const pRect = {x:this.player.x-20,y:this.player.y-20,w:40,h:40};
    for(let car of this.cars){ if(this.intersect(car.rect(),pRect)){ this.hit(); return; } }
    for(let t of this.trains){ t.update(dt); }
    this.trains = this.trains.filter(t=>(t.x+t.w>-300 && t.x<WIDTH+300));
    for(let t of this.trains){ if(this.intersect(t.rect(),pRect)){ this.hit(); return; } }

    for(let i=this.coinsArr.length-1;i>=0;i--){
      if(this.intersect(this.coinsArr[i].rect(),pRect)){
        this.coins++; saveProgress(); this.updateHUD();
        this.coinsArr.splice(i,1);
      }
    }

    this.trainTimer += dt;
    if(this.trainTimer >=1.5){
      this.trainTimer=0;
      const trainLane=this.lanes.find(l=>l.type==="train");
      if(trainLane){
        let y = trainLane.row*CELL + CELL/2;
        let dir = Math.random()<0.5?"left":"right";
        let speed = 450 + Math.random()*200;
        let x = dir==="right"?-600:WIDTH+600;
        this.trains.push(new Train(x,y,speed,dir));
      }
    }
  }

  onUp(){
    if(this.player.row===0 && !this.pendingReset){
      this.pendingReset = true;
      this.score++;
      this.generateMap(true);
      this.player.reset();
      this.pendingReset=false;
    }
  }

  hit(){ this.player.alive=false; this.gameOver=true; scoreEl.textContent="Hit! Score:"+this.score+" — Restart to play again"; }

  intersect(a,b){ return !(a.x+a.w<b.x || b.x+b.w<a.x || a.y+a.h<b.y || b.y+b.h<a.y); }

  draw(){
    ctx.clearRect(0,0,WIDTH,HEIGHT);
    for(let ln of this.lanes){
      let y = ln.row*CELL;
      if(ln.type==="safe"){ ctx.fillStyle="#8fdc7a"; ctx.fillRect(0,y,WIDTH,CELL); ctx.fillStyle="#6fb35f"; for(let i=0;i<COLUMNS;i++) ctx.fillRect(i*CELL+5,y+5,CELL-10,CELL-10);}
      else if(ln.type==="train"){ ctx.fillStyle="#663300"; ctx.fillRect(0,y,WIDTH,CELL); ctx.fillStyle="#444"; for(let i=0;i<COLUMNS;i++) ctx.fillRect(i*CELL+10,y+CELL/2-5,CELL-20,10);}
      else { ctx.fillStyle="#444"; ctx.fillRect(0,y,WIDTH,CELL); }
    }
    for(let t of this.trees) t.draw();
    for(let c of this.cars) c.draw();
    for(let t of this.trains) t.draw();
    for(let coin of this.coinsArr) coin.draw();
    this.player.draw();
  }

  updateHUD(){ scoreEl.textContent=`Score: ${this.score} | Coins: ${this.coins}`;}
}

// -------------------- Game Loop --------------------
let game = new Game();
function loop(t){ const dt = Math.min(0.05,(t-(game.lastTime||t))/1000); game.lastTime=t; game.update(dt); game.draw(); requestAnimationFrame(loop);}
requestAnimationFrame(loop);

// -------------------- Input --------------------
let keys={};
document.addEventListener("keydown", e=>{
  if(keys[e.key]) return; keys[e.key]=true;
  if(e.key==="ArrowUp"||e.key==="w") game.player.move("up");
  if(e.key==="ArrowDown"||e.key==="s") game.player.move("down");
  if(e.key==="ArrowLeft"||e.key==="a") game.player.move("left");
  if(e.key==="ArrowRight"||e.key==="d") game.player.move("right");
});
document.addEventListener("keyup", e=>keys[e.key]=false );

// -------------------- Restart --------------------
document.getElementById("restart").onclick=()=>{
  const coinsSaved = game.coins;
  const skinSaved = game.player.color;
  game = new Game();
  game.coins = coinsSaved; game.player.color = skinSaved; game.updateHUD();
}

// -------------------- Difficulty --------------------
difficultyEl.addEventListener("change", ()=>{game.setDifficulty(difficultyEl.value);});

// -------------------- Shop --------------------
document.getElementById("shopButton").onclick = ()=> document.getElementById("shopModal").style.display="block";
document.getElementById("closeShop").onclick = ()=> document.getElementById("shopModal").style.display="none";
document.getElementById("buyBox").onclick = ()=>{
  if(game.coins>=10){
    game.coins-=10; saveProgress();
    const colors = ["#2b8a3e","#8b0000","#ff69b4","#1e90ff","#ffa500","#4b0082","#00ced1","#ff1493","#228b22"];
    const newSkin = colors[randint(0,colors.length-1)];
    game.player.color = newSkin;
    if(!ownedSkins.includes(newSkin)) ownedSkins.push(newSkin);
    document.getElementById("newSkin").textContent="New skin!";
    game.updateHUD();
  } else document.getElementById("newSkin").textContent="Not enough coins!";
}

// -------------------- Skin Menu --------------------
document.getElementById("switchSkin").onclick = ()=>{
  const skinOptionsDiv = document.getElementById("skinOptions");
  skinOptionsDiv.innerHTML = "";
  for(let skin of ownedSkins){
    const btn = document.createElement("button");
    btn.style.backgroundColor = skin;
    btn.textContent = skin;
    btn.onclick = ()=>{
      game.player.color = skin; saveProgress(); document.getElementById("skinModal").style.display="none";
    };
    skinOptionsDiv.appendChild(btn);
  }
  document.getElementById("skinModal").style.display="block";
}
document.getElementById("closeSkinMenu").onclick = ()=> document.getElementById("skinModal").style.display="none";

// -------------------- Google Sign-In --------------------
function handleCredentialResponse(response){ console.log("Google ID token:", response.credential); }
window.onload = () => {
  google.accounts.id.initialize({client_id:"PUT_YOUR_GOOGLE_CLIENT_ID_HERE",callback:handleCredentialResponse});
  google.accounts.id.renderButton(document.getElementById("googleSignInButton"),{theme:"outline",size:"large",text:"signin_with"});
}

// -------------------- Resize --------------------
let resizeTimer = null;
window.addEventListener("resize", ()=>{
  if(resizeTimer) clearTimeout(resizeTimer);
  resizeTimer = setTimeout(()=>{
    WIDTH=window.innerWidth; HEIGHT=window.innerHeight;
    canvas.width=WIDTH; canvas.height=HEIGHT;
    COLUMNS=Math.max(MIN_COLUMNS, Math.min(Math.floor(WIDTH/CELL), MAX_COLUMNS));
    ROWS_VISIBLE=Math.max(MIN_ROWS, Math.min(Math.floor(HEIGHT/CELL), MAX_ROWS));
    game.generateMap(true);
    game.player.reset();
    resizeTimer=null;
  },150);
});
</script>
</body>
</html>
